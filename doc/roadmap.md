# Roadmap during the jam

This is a non-exhaustive list of programming and implementation tasks during the jam. Not included is any asset creation or integration steps; if assets are not available, draw plain circles or diamonds. This is ordered because later items generally depend on earlier ones.

1. Create a gameplay scene and structure it. Included are the background tilemap layer, foreground root (use YSort) parent to all foreground sprites and units. Implement basic camera controls: edge cursor pan, middle mouse button pan.
2. Create a main menu with a Start button to immediately launch the gameplay scene. Also include buttons to open a Credits/Legal menu and a Settings menu. These menus can be empty for now.
3. Figure out a data model which can be serialized, to support saving the game in the middle of a run. Create a user resource for the saved game state.
4. Set up a singleton which makes calls to the low-level Physics2DServer API each frame to move the units. Should be able to return saveable data, restore from saved data, and have method calls to add and remove units during runtime. The velocity of all units is hardcoded to 0 for now. Collision layers should be set for each faction of units as well as background static objects. In addition to tracking each unit's current velocity, also keep data for how far each unit has moved on its current trajectory, which will be needed for implementing pathfinding later.
5. Create the controls for the HUD within the gameplay scene and create spaces for minimap, unit info display, and order buttons. Configure it to accept input while the game is paused. Actual content can be placeholder/nonfunctional for now.
6. Create a timer heap singleton which keeps lightweight event objects (timestamp, calling unit/building, callback function) ordered by when the timer will elapse. This should be able to report serializable data for save and restore.
7. Add the following handlers to mouse input: deriving location from a right click to resolve orders, deriving location and any overlapped unit or building of a left buttons single click to select it, and deriving start and end locations for a left button drag to manipulate a 2D area in the backend Physics2DServer; when player units overlap, select those units. Callbacks can be empty methods for now.
8. Create a data model for the map data which accommodates the infection/purification mechanic (tiles can be swapped at runtime to other variants, and sprites placed upon that tile should also change accordingly). Tiles should have a static collision associated with them. Tile display might need to accommodate autotile display logic for borders between variants. Because this changes at runtime, this should accommodate save and load as well. Once the map is loaded, an AStar2D object containing tile connection information for pathfinding should be set up.
9. Create an invisible tilemap for buildings and logic for detecting if a spot is valid to build a building of a given layout, updating the building tilemap when a building is placed or destroyed. The building itself is still displayed as a sprite on the sprite layer. Other sprites overlapping the building should be hidden when a building materializes. This should accommodate save&load.
10. Create a data model for static (loaded on game start, does not change) data. This includes data about unit types, buildings, and unit upgrades. This also includes visual data about building sprites, unit sprite sheets, background object sprites, and textures for each of the variants. Create a registry for all this static data and implement reading this data in from a `.csv` spreadsheeton game load.
11. Create a data model for runtime data about units, buildings, and resources.
12. Now that unit parameters have been defined, move and attack-move orders can be implemented. Use the pathfinding resource created earlier to get paths, and query how much each unit has moved along its current trajectory to know when to start moving to the next point of the path. Some complexities regarding what formation units should take at the end of the path, how to gracefully handle halls and chokepoints, and units which move at different speeds should probably be thought about well beforehand, but is hopefully simplified by not having units of the same faction collide with each other.
13. Implement the resource economy; money which increases steadily over time, targetable "buildings" which increase the money increase rate when claimed, and targetable "buildings" which grant one of the special resource needed to build decontamination facilities. Notably, these "buildings" aren't useful to the enemy factions, who will simply destroy them when in the way. NPC factions only use money, and they gain it somewhat faster than the player does.
15. Implement a timer for the player getting new units gradually over time (more timers).
14. Implement sinks for money: unit upgrades and buildings.
15. Implement the infection/purification mechanic: infective tiles infect others on a timer when not near a decontamination facility or flag, and decontamination facilities/flags purify nearby tiles on a timer. If the entire map is infected, signal a game over.
12. Create a singleton which creates hitboxes for attacks upon request of attacking units by making calls to the Physics2DServer and sets callbacks for collision events with eligible units or buildings.
14. Implement all of the callback hooks for collisions and timers elapsing as managed by the heap or by the unit manager or hitbox manager singletons. Required to get gameplay properly working.
16. Implement player units respawning after defeat at the nearest decontamination facility (if none exist, then spawn them at the edge of the map, at the same place where new units spawn for the player). 
14. Create the AI "bot" which assigns player-like orders to a non-player faction. Should be tuned to account for enemy-specific mechanics, as many buildings are faction specific.
18. Implement new game init logic which spawns starting buildings and starting player units. Can be parameterized (support multiple difficulty settings). Set up a new game init menu invoked on "Start game" where these parameters can be set before launching the game.
19. Gather playtest data and begin iterating and polishing.


Here are unordered items which depend on one or more items of the above list, but nothing else depends on them. Some of them are pretty essential (minimap), others are "nice to have"s which may be skipped if the deadline looms too close.

* Implement a minimap with a draggable rectangle which moves the gameplay camera. Depends on having HUD frame set up.
* Implement setting control groups and using them to select a predefined group of units. Handle unit loss gracefully. Could be supported by save&load, doesn't have to be. Depends on mouse selection logic.
* Implement hotkey rebinding in the settings. Depends on there being at least one way to access the settings menu.
* Implement sound effect and music volume control in the settings. Depends on there being at least one way to access the settings menu.
* Implement a gameplay speed control in the settings. Depends on there being at least one way to access the settings menu.
* Add a pause menu to the gameplay scene which gives access to abandon game, save&quit, and settings. Also allow RTWP; a way of pausing the game without pulling up the menu to queue future orders.
* Name all contributors in the credits and include all license information for included outside assets and open source software in the credits as well. Depends on there being at least one way to access the credits screen.
* Create a menu for loading in a user pack containing data, asset files, and scripts. Enforce naming for these packs and ensure save files indicate which packs they are using. (Mod support) Depends on the static data data model. Probably out of scope for the jam itself, but design decisions can be made earlier to better accommodate this.

